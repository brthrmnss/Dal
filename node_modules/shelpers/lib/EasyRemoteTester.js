/**
 * Quick method to make post requests against server asnyc
 * @type {exports}
 */
var shelpers = require('shelpers')
var sh = shelpers.shelpers;
var PromiseHelperV3 = shelpers.PromiseHelperV3;
var express = require('express')
var GenerateData = shelpers.GenerateData;
var  test = {}

var Sequelize = require('sequelize')
var sequelize = null;



function EasyRemoteTester() {
    var self = this;


    var types = {};
    types.POST = 'POST'
    types.GET = 'GET'
    types.PUT = 'PUT'


    var TestHelper = shelpers.TestHelper;
    var reqPost = TestHelper.reqPost;


    function defineQuickRequests() {
        /**
         * Creates request for short command
         * @param url
         * @param method
         * @param fx
         * @param postData
         * @param doRegPost
         */
        self.quickRequest = function quickRequest(url, method, fx, postData, doRegPost) {
            if (method == null) {
                method = types.GET
            }
            var reqoptions = {}
            if ( url == null ) {
                throw 'url null'
            }
            reqoptions.url = url; //'http://localhost:' + self.settings.port + '/' + url
            if (postData == null) {
                postData = {}
            }
            method = method.toLowerCase();
            if (method == types.POST.toLowerCase() || method == types.PUT.toLowerCase()) {
                if (doRegPost) {
                    reqoptions.form = postData
                } else {
                    //reqoptions.json = true
                    //reqoptions.body = "gg"
                    reqoptions.json = true
                    reqoptions.body = postData
                }
            } else {
                reqoptions.qs = postData
            }

            console.log('    $')
            reqoptions.method = method
            self.settings.showBody = sh.dv(self.settings.showBody, true);
            reqoptions.showBody = self.settings.showBody;
            reqoptions.fx2 = function storeContents(body, resp) {
                self.proc(reqoptions.url, 'received result ok...')
                console.log('    ^E')
                try {
                    body = JSON.parse(body)
                } catch (e) {

                }

                self.lastRequestBody = body;
                self.lastResponse = resp;

                if (fx) {
                    fx(body, resp)
                }
            };
            reqoptions.name = 'test ' + sh.paren(url)

            reqoptions.request = self.request
            console.log('testing...')
            reqPost(reqoptions)
        }

    }
    defineQuickRequests();

    self.create = function create(token) {
        var verbs = {}
        verbs.actions = {}
        verbs.isJSON = 'isJSON'
        verbs.hasXResults = function hasXResults(amt) {


        }
        //has(6).results()
        //create task
        //list tasks
        //show all tasks
        //create task via put
        //create task


        /*

         new Verb().has(6).isJSON
         json.length == 6

         */

        self.settings = token;

        //var token = {}
        if (token == null) {
            token = {};
        }
        var workChain = new PromiseHelperV3();
        token.silentToken = true
        workChain.wait = token.simulate == false;
        workChain.startChain(token);//

        self.workChain= workChain;


        self.createHelpers();
        defineMergeChainWithRemote();

        if ( self.settings != null && self.settings.resetRequest == true ) {
            self.request =TestHelper.request(); ;
        }
        return workChain;
    }


    function defineUtils2() {
        /**
         * Test helper is a concurrent object that can be used to track
         * expected values of tests.
         */
        self.createHelpers = function createHelpers() {

            var data = {}
            data.expectedRecordLength = 100;//tasks.utils.getLength(); //tasks.records.length;
            data.checkRecordSize = function checkRecordSize() {
                return tasks.lastLength == data.expectedRecordLength
            }
            data.addItem = function addItem() {
                data.expectedRecordLength++;
            }
            data.removeItem = function removeItem() {
                data.expectedRecordLength--;
            }

            data.bodyHasError = function bodyHasError(bodyResponse) {
                if (sh.startsWith(bodyResponse, 'Cannot')) {
                    return true;
                }
                return sh.includes(bodyResponse, 'Error')
            }

            data.isFailure = function isFailure(resp) {
                return resp.statusCode == 404
            }


            data.assert = function assert(eq, msg) {
                var error = sh.errors.jumpError(msg, 5, eq, self.workChain.currentOperation.stack)
                if ( error ) {
                    setTimeout(function clearStout(){
                        process.exit()
                    },50)
                }
                /*if (eq == false) {
                 throw new Error(msg);
                 }*/
            }


            self.helper = data;
            data.workChain = self.workChain;
            return data;

        }

        /**
         * Method enables you to avoid passing the callback into the
         * test link.
         * Ex:
         * var t = new EasyRemoteTester();
         * function testChain2(token, cb) {
         *       console.log('testChain2');
         *       cb();
         *   }
         becomes:

         var t = new EasyRemoteTester();
         function testChain2() {
                console.log('testChain2');
                t.cb();
            }
         */
        self.cb = function cb_callCurrentCallback() {
            self.workChain.cb();
        }




        self.utils = {}
        self.utils.createTestingUrl = function createTestingUrl(end, port){
            var url = 'http://localhost'
            if  ( self.settings.baseUrl != null ) {
                url = 'http://' + self.settings.baseUrl
            }

            port = sh.dv(port, self.settings.port)
            port = sh.dv( self.settings.portOverride, port )

            if ( port != null ) {
                url += ':' + port;
            }
            if ( ! sh.startsWith(end , '/')){
                url += '/';
            }
            url += end;

            return url;
        }


        self.lastRequestOK = function lastRequestOK(msg){
            var okCode = 200;
            if (self.lastResponse.statusCode == 201 ) {
                okCode = 201;
            }
            if (self.lastResponse.statusCode == 202 ) {
                okCode = 202;
            }
            self.as2(self.lastResponse.statusCode , okCode, 'the last request failed')
        }
    }
    defineUtils2()


    function defineMergeChainWithRemote(){
        self.add = function add(fx) {
            self.workChain.add(fx);
        }
        self.addS = function addS(fx) {
            self.workChain.addS(fx);
        }
        self.addNext = function addNext(fx, offset) {
            self.workChain.addNext(fx, offset);
        }

        self.xadd = self.addS;
        self.assert = function assert(match, msg) {
            self.helper.assert(match, msg);
        }
        self.as2 = function as2(a,b, msg) {
            var fault = a==b
            if ( b == null ) {
                fault = a;
            }
            self.helper.assert(fault,
                sh.str.join(
                    msg, sh.paren(sh.str.join(a,'!=', b))
                ) );
        }
        self.wait = function wait(seconds, addToChain) {
            seconds = sh.dv(seconds, 3);
            return  self.workChain.utils.wait(seconds, addToChain);
        }
        /*self.quickRequest = function quickRequest() {
         sh.forwardArguments(arguments, self.helper.quickRequest)
         //self.helper.quickRequest(match, msg);
         }*/
        //self.quickRequest =  self.helper.quickRequest;

        self.addInner = function add(fx) {
            self.add(function addInnerTest() {

                fx(result)
                function result(body) {
                    console.log('<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>' )
                    self.cb();
                    return;
                }
            });
        }

    }



    /**
     * this examples how to use these methods
     */
    function defineUsages()
    {
        self.exampleCreateLocals = function exampleCreateLocals() {
            var assert = data.assert;
            var quickRequest = data.quickRequest;
        }
    }

    /**
     * Dev deocrates 'test' object. each method is converted into link
     */
    function defineTestUsageMode() {

        self.useTestUsageMode = function useTestUsageMode() {
            self.test = {};
            setTimeout(function convertTestItems() {
                // self.convertTestToChains();
            },0)
        }
        self.makeTest = self.useTestUsageMode;
    }
    defineTestUsageMode();



    function create() {

        function testUtilLinks() {
            self.reset = function reset(token, cb) {
                if (tasks.busy == true) {
                    //asdf.g.ds
                    work.tryLater();
                    return;
                    //setTimeout(self.reset, 500)
                }
                taskApiSettings.model = []
                GenerateData = shelpers.GenerateData;
                var gen = new GenerateData();
                /*taskApiSettings.model = gen.create(100, function (item, id, dp){
                 item.name = id;
                 item.id = id;

                 item.desc = GenerateData.getName();
                 })*/
                tasks.utils.empty(function onTableCleared() {
                    tasks.resetDp(function doneReset() {
                        data.expectedRecordLength = 100;
                        cb();
                    })
                })
                ;
                // assert(data.checkRecordSize(), 'did not reset')
            }

            self.getLength = function getLength(token, cb) {
                tasks.utils.getLength(function onGetLength(length) {
                    data.expectedRecordLength = length;
                    cb();
                })

            }

            self.checkRecordSize = function checkRecordSize(token, cb) {
                tasks.utils.getLength(function onGetLength(length) {
                    data.expectedRecordLength = length;
                    assert(data.checkRecordSize(), 'did not reset')
                    cb();
                })
            }

            /**
             * Checks record size, if fails assert, returns message
             * @param msg
             * @param cb
             */
            self.checkSize = function checkSize(msg, cb) {
                tasks.utils.getLength(function onGetLength(length) {
                    //data.expectedRecordLength = length;
                    assert(data.checkRecordSize(), msg + [tasks.lastLength , data.expectedRecordLength].join(','))
                    cb();
                })
            }


        }

        testUtilLinks();


        function testFauxGetRoutes() {

            work.add(self.reset);
            work.add(self.getLength)
            work.add(self.checkRecordSize);


            self.testGet = function testGet(token, cb) {
                self.quickRequest('api/' + tS.name, 'get', result, {id: "6"})
                function result(body) {
                    //return;
                    // tasks.showId(0, 'lll');
                    assert(body.id == 6, 'did not reset')
                    cb();
                }
            }
            //work.add(self.testGet);


            self.get_create = function get_create(token, cb) {
                self.quickRequest('api/' + tS.name + '/create', 'get', result, {name: "randomTask"})
                data.addItem();
                function result() {
                    self.checkSize('did not add task properly', cb)
                    //cb();
                }
            }
            work.add(self.get_create);


            self.get_update = function get_update(token, cb) {
                var newName = "randomTask_@"
                var idToUpdate = 3;
                self.quickRequest('api/' + tS.name + '/update', 'get', result,
                    {id: idToUpdate, name: newName})
                function result() {
                    tasks.getId(idToUpdate, function onGot(item) {
                        assert(item.dataValues.name == newName, 'did not restfully update task properly')
                        cb();
                    })
                }
            }
            work.add(self.get_update);


            self.get_update = function get_create(token, cb) {
                var newName = "randomTask_@"
                var idToUpdate = 4;
                self.quickRequest('api/' + tS.name + '/update', 'get', result,
                    {id: idToUpdate, name: newName})
                function result() {
                    tasks.getId(idToUpdate, function onGot(item) {
                        assert(item.dataValues.name == newName, 'did not restfully update task properly')
                        cb();
                    })
                }
            }
            work.add(self.get_update);

            self.get_update_wrong = function get_create(token, cb) {
                var newName = "randomTask_@"
                self.quickRequest('api/' + tS.name + '/update', 'get', result, {id: -1, name: newName})
                function result(body) {
                    var ok = sh.includes(body, types.errors.recordDoesNotExist);
                    assert(ok,
                        'let me update an invalid task')
                    cb();
                }
            }
            work.add(self.get_update_wrong);

            self.get_delete = function get_delete(token, cb) {
                var newName = "randomTask_@"
                data.removeItem()
                self.quickRequest('api/' + tS.name + '/delete', 'get', result,
                    {id: 8, name: newName})
                function result(body) {
                    self.checkSize(
                        'did not delete task properly', cb)
                    //cb();
                }
            }
            work.add(self.get_delete);

            self.get_delete_with_id_broken = function get_delete_with_id_broken(token, cb) {
                var newName = "randomTask_@"
                // data.removeItem()
                self.quickRequest('api/' + tS.name + '/delete/' + -1, 'get',
                    result, {id: -1, name: newName})
                function result(body) {
                    var ok = data.bodyHasError(body)
                    assert(ok,
                        'did not delete task properly broken');
                    self.checkSize(
                        'did not delete task properly', cb)
                }
            }
            work.add(self.get_delete_with_id_broken);


            self.get_delete_with_id = function get_delete_with_id(token, cb) {
                data.removeItem();
                self.quickRequest('api/' + tS.name + '/delete/' + 2, 'get', result, {id: -1})
                function result(body) {
                    self.checkSize(
                        'did not delete task properly', cb)
                }
            }
            work.add(self.get_delete_with_id);

        }


        testFauxGetRoutes();


        function testRestRoutes() {

            work.add(self.reset);
            work.add(self.getLength)
            work.add(self.checkRecordSize);


            self.testRestGet = function testRestGet(token, cb) {
                var itemId = 1;
                self.quickRequest('api/' + tS.name + '/' + itemId, 'get', result)
                function result(body) {
                    assert(body.id == itemId, 'did not get item')
                    cb();
                }
            }
            work.add(self.testRestGet);


            self.rest_create = function rest_create(token, cb) {
                // adsf.g.d
                self.quickRequest('api/' + tS.name, 'POST', result, {name: " rand task"})
                data.addItem();
                function result(body) {
                    self.checkSize('did not add task properly', cb);
                    //assert(data.checkRecordSize(), 'did not add task properly')
                    // ();
                }
            }
            work.add(self.rest_create);


            self.rest_create_upsert_fail = function rest_create(token, cb) {
                self.quickRequest('api/' + tS.name, 'POST', result,
                    {name: " rand task2__", upsertQuery: {desc: "<><>"} })
                data.addItem();
                function result(body) {
                    //self.proc('what?...')
                    console.log('what?...');
                    self.checkSize('upsert, did not add task properly', cb);
                }
            }
            work.add(self.rest_create_upsert_fail);


            self.rest_create_upsert_2 = function rest_create(token, cb) {
                self.quickRequest('api/' + tS.name, 'POST', result,
                    {name: " rand task2", upsertQuery: {name: " rand task2"} })
                //data.addItem();
                function result(body) {
                    //self.proc('what?...')
                    console.log('what?...');
                    self.checkSize('upsert, why did you add tag?', cb);
                }
            }
            work.add(self.rest_create_upsert_2);

            //work.add(self.getLength);
            //work.add(self.checkRecordSize);
            //


            self.rest_update = function rest_update(token, cb) {
                var newName = "randomTask_@"
                var idToUpdate = 1
                self.quickRequest('api/' + tS.name + '/' + idToUpdate, 'PUT', result, {id: idToUpdate, name: newName})
                function result() {

                    tasks.getId(idToUpdate, function onGot(item) {
                        assert(item.dataValues.name == newName, 'did not restfully update task properly')
                        cb();
                    })


                }
            }
            work.add(self.rest_update);


            self.rest_update_wrong = function rest_update_wrong(token, cb) {
                var newName = "randomTask_@"
                self.quickRequest('api/' + tS.name + '/' + 9999, 'get', result, {id: 0, name: newName})
                function result() {
                    assert(tasks.getId(0).name == newName, 'did not add task properly')
                    cb();
                }
            }
            //work.add(self.rest_update_wrong);

            self.get_update_wrong = function get_create(token, cb) {
                var newName = "randomTask_@"
                self.quickRequest('api/' + tS.name + '/' + "-1", 'get', result, {id: -1, name: newName})
                function result(body, resp) {
                    assert(data.isFailure(resp), 'Updaded invalid id')
                    // assert(sh.includes(body, types.errors.recordDoesNotExist),
                    //     'let me update an invalid task')
                    cb();
                }
            }
            work.add(self.get_update_wrong);

            self.rest_delete = function rest_delete(token, cb) {
                var newName = "randomTask_@"
                data.removeItem()
                var deleteId = 1;
                self.quickRequest('api/' + tS.name + '/' + deleteId, 'DELETE', result)
                function result(body) {


                    self.checkSize('did not delete task properly', cb)
                    //assert(data.checkRecordSize(),
                    //   'did not delete task properly')
                    //cb();
                }
            }
            work.add(self.rest_delete);

            self.rest_delete_with_id_broken = function get_delete_with_id_broken(token, cb) {
                var newName = "randomTask_@"
                self.quickRequest('api/' + tS.name + '/delete/' + 6, 'DELETE', result)
                function result(body) {
                    assert(data.bodyHasError(body),
                        'did not delete task properly broken');
                    //assert(data.checkrecordsize(),
                    //    'did not delete task properly broken');
                    cb();
                }
            }
            work.add(self.rest_delete_with_id_broken);


            self.rest_delete_with_id = function rest_delete_with_id(token, cb) {
                data.removeItem();
                self.quickRequest('api/' + tS.name + '/delete/' + 2, 'get', result, {id: -1})
                function result(body) {
                    self.checkSize('did not delete task properly', cb)
                }
            }
            work.add(self.rest_delete_with_id);

            self.rest_list = function rest_list(token, cb) {
                self.quickRequest('api/' + tS.name, 'get', result, {id: -1})
                function result(body) {
                    self.checkSize('did not delete task properly', cb)
                }
            }
            work.add(self.rest_list);
        }

        testRestRoutes();

        /*

         self.quickRequest('api/'+tS.name+'/update', 'get', null, {id:0, name:"randomTask_@"})
         self.quickRequest('api/'+tS.name+'/update', 'get', null, {id:-1, name:"randomTask_@"})

         self.quickRequest('api/'+tS.name+'/0', 'get', null, {id:-1, name:"randomTask_@"})
         self.quickRequest('api/'+tS.name+'/delete', 'get', null, {id:-1, name:"randomTask_@"})


         //l crud//
         self.quickRequest('api/tasks', 'get', null, {user_id:"6"})
         self.quickRequest('api/tasks', 'put', null, {name:"randomTask"})
         self.quickRequest('api/'+tS.name+'/1', 'get', null )
         self.quickRequest('api/'+tS.name+'/1', 'get', null, {id:-1, name:"randomTask_@"})
         self.quickRequest('api/'+tS.name+'/1', 'delete', null )

         self.quickRequest('api/'+tS.name+'/search', 'get', null, {id:-1, name:"randomTask", __limit:1})
         self.quickRequest('api/'+tS.name+'/search', 'get', null, {id:1, name:"randomTask", __limit:1, __exact:true})


         self.quickRequest('api/'+tS.name+'/0', 'get', null, {id:-1, name:"randomTask_@"})
         self.quickRequest('api/'+tS.name+'/delete', 'get', null, {id:-1, name:"randomTask_@"})
         */


        function testSearchRoute() {

            work.add(self.reset);
            work.add(self.getLength)
            work.add(self.checkRecordSize);

            function defineTestSearch() {


                self.testQuerySearch = function testQuerySearch(token, cb) {
                    self.quickRequest('api/' + tS.name + '/search', 'get', result,
                        {query://{name:{$like: '%hat'}
                            ["name LIKE ?", "%1%"]
                            //}
                        })
                    //{query:{name:{$like:'%1%'}}} )
                    function result(body) {
                        assert(body.length == 10, 'did not get enough results')
                        cb();
                    }
                }
                work.add(self.testQuerySearch);


                self.testQuerySearch_limit = function testQuerySearch(token, cb) {
                    //self.quickRequest('api/'+tS.name+'/search', 'get', result, {query:{name:1}, limit:10} )
                    self.quickRequest('api/' + tS.name + '/search', 'get', result,
                        {query://{name:{$like: '%hat'}
                            ["name LIKE ?", "%1"]
                            //}
                        })
                    function result(body) {
                        assert(body.length == 10, 'did not get enough results')
                        cb();
                    }
                }
                work.add(self.testQuerySearch_limit);


                self.testQuerySearch_limit_1 = function testQuerySearch(token, cb) {
                    self.quickRequest('api/' + tS.name + '/search', 'get', result,
                        {query: {name: 11}, limit: 10})
                    function result(body) {
                        assert(body.length == 1, 'did not get enough results')
                        cb();
                    }
                }
                work.add(self.testQuerySearch_limit_1);


                self.changeDescOnItem = function changeDescOnItem(token, cb) {
                    tasks.getId(11, function onGot(item) {
                        token.item = item;
                        token.newDesc = "Find Desc"


                        tasks.utils.updateItem({desc: "Find Desc"}, item, function onSaved(o) {
                            cb();
                        });


                    })
                }
                work.add(self.changeDescOnItem);

                //return

                self.testQuerySearch_limit_piecemeal = function testQuerySearch(token, cb) {
                    // tasks.getId(11).desc = 'Find Desc'
                    self.quickRequest('api/' + tS.name + '/search', 'get', result,
                        {name: "10", desc: token.newDesc})
                    function result(body) {
                        assert(body.length == 1, 'did not get enough results')
                        cb();
                    }
                }
                work.add(self.testQuerySearch_limit_piecemeal);

                self.testQuerySearch_limit_piecemealb = function testQuerySearch(token, cb) {
                    // tasks.getId(11).desc = 'Find Desc';
                    self.quickRequest('api/' + tS.name + '/search', 'get', result,
                        {name: "11", desc: tasks.getId(11).desc.slice(0, 6)})
                    function result(body) {
                        assert(body.length == 1, 'search doesn\'t work on wild cards');
                        cb();
                    }
                }
                //  work.add(self.testQuerySearch_limit_piecemealb);

                self.testQuerySearch_limit_piecemealb_findNone = function testQuerySearch(token, cb) {
                    // tasks.getId(11).desc = 'Find Desc';
                    self.quickRequest('api/' + tS.name + '/search', 'get', result,
                        {name: "11", desc: 'llll'})
                    function result(body) {
                        assert(body.length == 0, 'search return more than 0 results for bad query');
                        cb();
                    }
                }
                work.add(self.testQuerySearch_limit_piecemealb_findNone);

            }

            defineTestSearch()


            //crud

            /* setTimeout(function () {
             tasks.showId(0, 'lll');
             }, 500)*/

        }


        testSearchRoute();


        function testUserId() {
            work.add(self.reset);
            work.add(self.getLength)
            work.add(self.checkRecordSize);


            self.setupUserIdTesting = function setupUserIdTesting(token, cb) {
                tS.fxGetUserId = function getUserId(req) {
                    return 4;
                }

                cb();

            }
            work.add(self.setupUserIdTesting);

            self.testUpdateToUserId = function testUpdateToUserId(token, cb) {

                var idToUpdate = 1

                tasks.getId(idToUpdate, function onGot(item) {

                    tasks.utils.updateItem({user_id: 4}, item, cb2)

                    function cb2(o) {
                        cb();
                    }

                    //assert(item.dataValues.name == newName, 'did not restfully update task properly')
                    //cb();
                })


            }
            work.add(self.testUpdateToUserId);


            self.testRestGet = function testRestGet(token, cb) {
                var itemId = 1;
                self.quickRequest('api/' + tS.name + '/' + itemId, 'get', result)
                function result(body) {
                    assert(body.id == itemId, 'did not get item')
                    cb();
                }
            }
            work.add(self.testRestGet);

            self.testRestGet_BadUserId = function testRestGet(token, cb) {
                var itemId = 1 + 1;
                self.quickRequest('api/' + tS.name + '/' + itemId, 'get', result)
                function result(body) {
                    assert(body == '', 'return item from get you should not have')
                    cb();
                }
            }
            work.add(self.testRestGet_BadUserId);


            self.rest_create = function rest_create(token, cb) {
                // adsf.g.d
                self.quickRequest('api/' + tS.name, 'POST', result, {name: " rand task"})
                data.addItem();
                function result(body) {
                    self.checkSize('did not add task properly', cb);
                    //assert(data.checkRecordSize(), 'did not add task properly')
                    // ();

                    //list and get last id?
                }
            }
            work.add(self.rest_create);


            self.rest_update = function rest_update(token, cb) {
                var newName = "randomTask_@"
                var idToUpdate = 1
                self.quickRequest('api/' + tS.name + '/' + idToUpdate, 'PUT', result, {id: idToUpdate, name: newName})
                function result() {

                    tasks.getId(idToUpdate, function onGot(item) {
                        assert(item.dataValues.name == newName, 'did not restfully update task properly')
                        cb();
                    })


                }
            }
            work.add(self.rest_update);


            self.rest_update_wrong = function rest_update_wrong(token, cb) {
                var newName = "randomTask_@"
                var idToUpdate = 8
                self.quickRequest('api/' + tS.name + '/' + idToUpdate, 'get', result, {id: 0, name: newName})
                function result() {
                    tasks.settings.userId = null;
                    tasks.getId(idToUpdate, function onGot(item) {
                        assert(item.dataValues.name != newName, 'did not restfully update task properly')
                        cb();
                    })
                }
            }
            work.add(self.rest_update_wrong);

            self.get_update_wrong = function get_create(token, cb) {
                var newName = "randomTask_@"
                self.quickRequest('api/' + tS.name + '/' + "-1", 'get', result, {id: -1, name: newName})
                function result(body, resp) {
                    assert(data.isFailure(resp), 'Updaded invalid id')
                    // assert(sh.includes(body, types.errors.recordDoesNotExist),
                    //     'let me update an invalid task')
                    cb();
                }
            }
            work.add(self.get_update_wrong);

            self.rest_delete = function rest_delete(token, cb) {
                var newName = "randomTask_@"
                data.removeItem()
                var deleteId = 1;
                self.quickRequest('api/' + tS.name + '/' + deleteId, 'DELETE', result)
                function result(body) {


                    self.checkSize('__did not delete task properly', cb)
                    //assert(data.checkRecordSize(),
                    //   'did not delete task properly')
                    //cb();
                }
            }
            work.add(self.rest_delete);

            self.rest_delete_with_id_broken = function get_delete_with_id_broken(token, cb) {
                var newName = "randomTask_@"
                self.quickRequest('api/' + tS.name + '/delete/' + 6, 'DELETE', result)
                function result(body) {
                    assert(data.bodyHasError(body),
                        'did not delete task properly broken');
                    //assert(data.checkrecordsize(),
                    //    'did not delete task properly broken');
                    cb();
                }
            }
            work.add(self.rest_delete_with_id_broken);


            self.rest_delete_with_id = function rest_delete_with_id(token, cb) {
                //data.removeItem();
                self.quickRequest('api/' + tS.name + '/delete/' + 2, 'get', result, {id: -1})
                function result(body) {
                    self.checkSize('did not delete task properly', cb)
                }
            }
            work.add(self.rest_delete_with_id);

            self.rest_list = function rest_list(token, cb) {
                self.quickRequest('api/' + tS.name, 'get', result, {id: -1})
                function result(body) {
                    self.checkSize('did not delete task properly', cb)
                }
            }
            work.add(self.rest_list);
        }

        testUserId();
    }


    self.proc = function proc() {
        sh.sLog(arguments)
    }
}

/**
 * Recommended usage until API matures
 * @param settings
 */
EasyRemoteTester.create = function create(name, settings) {
    var t = new EasyRemoteTester();
    if ( settings == null ){
        settings = {}
    }
    if ( settings != null ) {
        if ( settings.name == null && name != null ) {
            settings.name = name;
        }
    }
    var work = t.create(settings)
    //var tH = t.createHelpers();
    return t;
}

exports.EasyRemoteTester = EasyRemoteTester;

/**
 * Use to convert test work-links into chain
 *
 * @constructor
 */
function TestQueue() {

    var p = TestQueue.prototype;
    p = this;
    var self = this;
    p.initTestQueue = function initTestQueue(settings) {
        var t = EasyRemoteTester.create('test get confi API',settings);
        self.t = t;
        return t;
    }

    /**
     * Add work to chain
     * @param callback
     */
    p.add = function add(callback) {
        self.t.add(function filesStored() {
            sh.logLine(2);
            //log name of function
            callback(function finished(){
                sh.logLine(2)
                t.cb();

            })
        })
    }

    p.proc = function debugLogger() {
        if ( self.silent == true) {
            return
        }
        sh.sLog(arguments)
    }




}


exports.TestQueue = TestQueue;

if ( module.parent == null ) {



    var t = new EasyRemoteTester();
    var work = t.create();
    var tH = t.createHelpers();
    var assert = tH.assert; var quickRequest = tH.quickRequest;

    function testChain(token, cb) {
        console.log('testChain');
        cb();
    }
    work.add(testChain);

    function testChain_addTime() {
        console.log('add time');
        times++;
        work.addNext(testChain_AddNext);
        t.cb();
    }

    var times = 0;
    function testChain_AddNext(token, cb) {
        console.log('testChain2')
        if ( times > 3) {
            t.cb();
        } else {
            t.addNext(t.wait(1,false),0);
            t.addNext(testChain_addTime,1);
            t.cb();
        }
    }
    work.add(testChain_AddNext);


    function testYahoo(token, cb) {
        console.log('test yahoo')
        cb()
        t.quickRequest('http://www.yahoo.com',  null, function result(d){
            function result(body) {
                //var ok = tH.bodyHasError(body)
                assert(body!=null,
                    'did not delete task properly broken');
                // self.checkSize(
                //    'did not delete task properly', cb)
                cb()
            }
        })
    }
    work.add(testYahoo)


    //testRestHelper();
    //setTimeout(testRestHelper, 5000); //wait for db to create records

}

